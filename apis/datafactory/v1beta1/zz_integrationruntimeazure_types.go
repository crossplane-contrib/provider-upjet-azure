// SPDX-FileCopyrightText: 2023 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type IntegrationRuntimeAzureInitParameters struct {

	// Cluster will not be recycled and it will be used in next data flow activity run until TTL (time to live) is reached if this is set as false. Default is true.
	CleanupEnabled *bool `json:"cleanupEnabled,omitempty" tf:"cleanup_enabled,omitempty"`

	// Compute type of the cluster which will execute data flow job. Valid values are General, ComputeOptimized and MemoryOptimized. Defaults to General.
	ComputeType *string `json:"computeType,omitempty" tf:"compute_type,omitempty"`

	// Core count of the cluster which will execute data flow job. Valid values are 8, 16, 32, 48, 80, 144 and 272. Defaults to 8.
	CoreCount *float64 `json:"coreCount,omitempty" tf:"core_count,omitempty"`

	// Integration runtime description.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Specifies the supported Azure location where the resource exists. Use AutoResolve to create an auto-resolve integration runtime. Changing this forces a new resource to be created.
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// Time to live (in minutes) setting of the cluster which will execute data flow job. Defaults to 0.
	TimeToLiveMin *float64 `json:"timeToLiveMin,omitempty" tf:"time_to_live_min,omitempty"`

	// Is Integration Runtime compute provisioned within Managed Virtual Network? Changing this forces a new resource to be created.
	VirtualNetworkEnabled *bool `json:"virtualNetworkEnabled,omitempty" tf:"virtual_network_enabled,omitempty"`
}

type IntegrationRuntimeAzureObservation struct {

	// Cluster will not be recycled and it will be used in next data flow activity run until TTL (time to live) is reached if this is set as false. Default is true.
	CleanupEnabled *bool `json:"cleanupEnabled,omitempty" tf:"cleanup_enabled,omitempty"`

	// Compute type of the cluster which will execute data flow job. Valid values are General, ComputeOptimized and MemoryOptimized. Defaults to General.
	ComputeType *string `json:"computeType,omitempty" tf:"compute_type,omitempty"`

	// Core count of the cluster which will execute data flow job. Valid values are 8, 16, 32, 48, 80, 144 and 272. Defaults to 8.
	CoreCount *float64 `json:"coreCount,omitempty" tf:"core_count,omitempty"`

	// The Data Factory ID in which to associate the Linked Service with. Changing this forces a new resource.
	DataFactoryID *string `json:"dataFactoryId,omitempty" tf:"data_factory_id,omitempty"`

	// Integration runtime description.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Specifies the supported Azure location where the resource exists. Use AutoResolve to create an auto-resolve integration runtime. Changing this forces a new resource to be created.
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// Time to live (in minutes) setting of the cluster which will execute data flow job. Defaults to 0.
	TimeToLiveMin *float64 `json:"timeToLiveMin,omitempty" tf:"time_to_live_min,omitempty"`

	// Is Integration Runtime compute provisioned within Managed Virtual Network? Changing this forces a new resource to be created.
	VirtualNetworkEnabled *bool `json:"virtualNetworkEnabled,omitempty" tf:"virtual_network_enabled,omitempty"`
}

type IntegrationRuntimeAzureParameters struct {

	// Cluster will not be recycled and it will be used in next data flow activity run until TTL (time to live) is reached if this is set as false. Default is true.
	// +kubebuilder:validation:Optional
	CleanupEnabled *bool `json:"cleanupEnabled,omitempty" tf:"cleanup_enabled,omitempty"`

	// Compute type of the cluster which will execute data flow job. Valid values are General, ComputeOptimized and MemoryOptimized. Defaults to General.
	// +kubebuilder:validation:Optional
	ComputeType *string `json:"computeType,omitempty" tf:"compute_type,omitempty"`

	// Core count of the cluster which will execute data flow job. Valid values are 8, 16, 32, 48, 80, 144 and 272. Defaults to 8.
	// +kubebuilder:validation:Optional
	CoreCount *float64 `json:"coreCount,omitempty" tf:"core_count,omitempty"`

	// The Data Factory ID in which to associate the Linked Service with. Changing this forces a new resource.
	// +crossplane:generate:reference:type=github.com/upbound/provider-azure/apis/datafactory/v1beta1.Factory
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	DataFactoryID *string `json:"dataFactoryId,omitempty" tf:"data_factory_id,omitempty"`

	// Reference to a Factory in datafactory to populate dataFactoryId.
	// +kubebuilder:validation:Optional
	DataFactoryIDRef *v1.Reference `json:"dataFactoryIdRef,omitempty" tf:"-"`

	// Selector for a Factory in datafactory to populate dataFactoryId.
	// +kubebuilder:validation:Optional
	DataFactoryIDSelector *v1.Selector `json:"dataFactoryIdSelector,omitempty" tf:"-"`

	// Integration runtime description.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Specifies the supported Azure location where the resource exists. Use AutoResolve to create an auto-resolve integration runtime. Changing this forces a new resource to be created.
	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// Time to live (in minutes) setting of the cluster which will execute data flow job. Defaults to 0.
	// +kubebuilder:validation:Optional
	TimeToLiveMin *float64 `json:"timeToLiveMin,omitempty" tf:"time_to_live_min,omitempty"`

	// Is Integration Runtime compute provisioned within Managed Virtual Network? Changing this forces a new resource to be created.
	// +kubebuilder:validation:Optional
	VirtualNetworkEnabled *bool `json:"virtualNetworkEnabled,omitempty" tf:"virtual_network_enabled,omitempty"`
}

// IntegrationRuntimeAzureSpec defines the desired state of IntegrationRuntimeAzure
type IntegrationRuntimeAzureSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     IntegrationRuntimeAzureParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider IntegrationRuntimeAzureInitParameters `json:"initProvider,omitempty"`
}

// IntegrationRuntimeAzureStatus defines the observed state of IntegrationRuntimeAzure.
type IntegrationRuntimeAzureStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        IntegrationRuntimeAzureObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// IntegrationRuntimeAzure is the Schema for the IntegrationRuntimeAzures API. Manages a Data Factory Azure Integration Runtime.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type IntegrationRuntimeAzure struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.location) || (has(self.initProvider) && has(self.initProvider.location))",message="spec.forProvider.location is a required parameter"
	Spec   IntegrationRuntimeAzureSpec   `json:"spec"`
	Status IntegrationRuntimeAzureStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// IntegrationRuntimeAzureList contains a list of IntegrationRuntimeAzures
type IntegrationRuntimeAzureList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []IntegrationRuntimeAzure `json:"items"`
}

// Repository type metadata.
var (
	IntegrationRuntimeAzure_Kind             = "IntegrationRuntimeAzure"
	IntegrationRuntimeAzure_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: IntegrationRuntimeAzure_Kind}.String()
	IntegrationRuntimeAzure_KindAPIVersion   = IntegrationRuntimeAzure_Kind + "." + CRDGroupVersion.String()
	IntegrationRuntimeAzure_GroupVersionKind = CRDGroupVersion.WithKind(IntegrationRuntimeAzure_Kind)
)

func init() {
	SchemeBuilder.Register(&IntegrationRuntimeAzure{}, &IntegrationRuntimeAzureList{})
}
