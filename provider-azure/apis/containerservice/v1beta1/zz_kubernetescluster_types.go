/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AciConnectorLinuxObservation struct {
}

type AciConnectorLinuxParameters struct {

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-azure/apis/network/v1beta1.Subnet
	// +kubebuilder:validation:Optional
	SubnetName *string `json:"subnetName,omitempty" tf:"subnet_name,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetNameRef *v1.Reference `json:"subnetNameRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	SubnetNameSelector *v1.Selector `json:"subnetNameSelector,omitempty" tf:"-"`
}

type AllowedObservation struct {
}

type AllowedParameters struct {

	// +kubebuilder:validation:Required
	Day *string `json:"day" tf:"day,omitempty"`

	// +kubebuilder:validation:Required
	Hours []*float64 `json:"hours" tf:"hours,omitempty"`
}

type AutoScalerProfileObservation struct {
}

type AutoScalerProfileParameters struct {

	// +kubebuilder:validation:Optional
	BalanceSimilarNodeGroups *bool `json:"balanceSimilarNodeGroups,omitempty" tf:"balance_similar_node_groups,omitempty"`

	// +kubebuilder:validation:Optional
	EmptyBulkDeleteMax *string `json:"emptyBulkDeleteMax,omitempty" tf:"empty_bulk_delete_max,omitempty"`

	// +kubebuilder:validation:Optional
	Expander *string `json:"expander,omitempty" tf:"expander,omitempty"`

	// +kubebuilder:validation:Optional
	MaxGracefulTerminationSec *string `json:"maxGracefulTerminationSec,omitempty" tf:"max_graceful_termination_sec,omitempty"`

	// +kubebuilder:validation:Optional
	MaxNodeProvisioningTime *string `json:"maxNodeProvisioningTime,omitempty" tf:"max_node_provisioning_time,omitempty"`

	// +kubebuilder:validation:Optional
	MaxUnreadyNodes *float64 `json:"maxUnreadyNodes,omitempty" tf:"max_unready_nodes,omitempty"`

	// +kubebuilder:validation:Optional
	MaxUnreadyPercentage *float64 `json:"maxUnreadyPercentage,omitempty" tf:"max_unready_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	NewPodScaleUpDelay *string `json:"newPodScaleUpDelay,omitempty" tf:"new_pod_scale_up_delay,omitempty"`

	// +kubebuilder:validation:Optional
	ScaleDownDelayAfterAdd *string `json:"scaleDownDelayAfterAdd,omitempty" tf:"scale_down_delay_after_add,omitempty"`

	// +kubebuilder:validation:Optional
	ScaleDownDelayAfterDelete *string `json:"scaleDownDelayAfterDelete,omitempty" tf:"scale_down_delay_after_delete,omitempty"`

	// +kubebuilder:validation:Optional
	ScaleDownDelayAfterFailure *string `json:"scaleDownDelayAfterFailure,omitempty" tf:"scale_down_delay_after_failure,omitempty"`

	// +kubebuilder:validation:Optional
	ScaleDownUnneeded *string `json:"scaleDownUnneeded,omitempty" tf:"scale_down_unneeded,omitempty"`

	// +kubebuilder:validation:Optional
	ScaleDownUnready *string `json:"scaleDownUnready,omitempty" tf:"scale_down_unready,omitempty"`

	// +kubebuilder:validation:Optional
	ScaleDownUtilizationThreshold *string `json:"scaleDownUtilizationThreshold,omitempty" tf:"scale_down_utilization_threshold,omitempty"`

	// +kubebuilder:validation:Optional
	ScanInterval *string `json:"scanInterval,omitempty" tf:"scan_interval,omitempty"`

	// +kubebuilder:validation:Optional
	SkipNodesWithLocalStorage *bool `json:"skipNodesWithLocalStorage,omitempty" tf:"skip_nodes_with_local_storage,omitempty"`

	// +kubebuilder:validation:Optional
	SkipNodesWithSystemPods *bool `json:"skipNodesWithSystemPods,omitempty" tf:"skip_nodes_with_system_pods,omitempty"`
}

type AzureActiveDirectoryRoleBasedAccessControlObservation struct {
}

type AzureActiveDirectoryRoleBasedAccessControlParameters struct {

	// +kubebuilder:validation:Optional
	AdminGroupObjectIds []*string `json:"adminGroupObjectIds,omitempty" tf:"admin_group_object_ids,omitempty"`

	// +kubebuilder:validation:Optional
	AzureRbacEnabled *bool `json:"azureRbacEnabled,omitempty" tf:"azure_rbac_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	ClientAppID *string `json:"clientAppId,omitempty" tf:"client_app_id,omitempty"`

	// +kubebuilder:validation:Optional
	Managed *bool `json:"managed,omitempty" tf:"managed,omitempty"`

	// +kubebuilder:validation:Optional
	ServerAppID *string `json:"serverAppId,omitempty" tf:"server_app_id,omitempty"`

	// +kubebuilder:validation:Optional
	ServerAppSecretSecretRef *v1.SecretKeySelector `json:"serverAppSecretSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	TenantID *string `json:"tenantId,omitempty" tf:"tenant_id,omitempty"`
}

type DefaultNodePoolObservation struct {
}

type DefaultNodePoolParameters struct {

	// +kubebuilder:validation:Optional
	EnableAutoScaling *bool `json:"enableAutoScaling,omitempty" tf:"enable_auto_scaling,omitempty"`

	// +kubebuilder:validation:Optional
	EnableHostEncryption *bool `json:"enableHostEncryption,omitempty" tf:"enable_host_encryption,omitempty"`

	// +kubebuilder:validation:Optional
	EnableNodePublicIP *bool `json:"enableNodePublicIp,omitempty" tf:"enable_node_public_ip,omitempty"`

	// +kubebuilder:validation:Optional
	FipsEnabled *bool `json:"fipsEnabled,omitempty" tf:"fips_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	KubeletConfig []KubeletConfigParameters `json:"kubeletConfig,omitempty" tf:"kubelet_config,omitempty"`

	// +kubebuilder:validation:Optional
	KubeletDiskType *string `json:"kubeletDiskType,omitempty" tf:"kubelet_disk_type,omitempty"`

	// +kubebuilder:validation:Optional
	LinuxOsConfig []LinuxOsConfigParameters `json:"linuxOsConfig,omitempty" tf:"linux_os_config,omitempty"`

	// +kubebuilder:validation:Optional
	MaxCount *float64 `json:"maxCount,omitempty" tf:"max_count,omitempty"`

	// +kubebuilder:validation:Optional
	MaxPods *float64 `json:"maxPods,omitempty" tf:"max_pods,omitempty"`

	// +kubebuilder:validation:Optional
	MinCount *float64 `json:"minCount,omitempty" tf:"min_count,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	NodeCount *float64 `json:"nodeCount,omitempty" tf:"node_count,omitempty"`

	// +kubebuilder:validation:Optional
	NodeLabels map[string]*string `json:"nodeLabels,omitempty" tf:"node_labels,omitempty"`

	// +kubebuilder:validation:Optional
	NodePublicIPPrefixID *string `json:"nodePublicIpPrefixId,omitempty" tf:"node_public_ip_prefix_id,omitempty"`

	// +kubebuilder:validation:Optional
	NodeTaints []*string `json:"nodeTaints,omitempty" tf:"node_taints,omitempty"`

	// +kubebuilder:validation:Optional
	OnlyCriticalAddonsEnabled *bool `json:"onlyCriticalAddonsEnabled,omitempty" tf:"only_critical_addons_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	OrchestratorVersion *string `json:"orchestratorVersion,omitempty" tf:"orchestrator_version,omitempty"`

	// +kubebuilder:validation:Optional
	OsDiskSizeGb *float64 `json:"osDiskSizeGb,omitempty" tf:"os_disk_size_gb,omitempty"`

	// +kubebuilder:validation:Optional
	OsDiskType *string `json:"osDiskType,omitempty" tf:"os_disk_type,omitempty"`

	// +kubebuilder:validation:Optional
	OsSku *string `json:"osSku,omitempty" tf:"os_sku,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-azure/apis/network/v1beta1.Subnet
	// +crossplane:generate:reference:extractor=github.com/upbound/official-providers/provider-azure/apis/rconfig.ExtractResourceID()
	// +kubebuilder:validation:Optional
	PodSubnetID *string `json:"podSubnetId,omitempty" tf:"pod_subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	PodSubnetIDRef *v1.Reference `json:"podSubnetIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	PodSubnetIDSelector *v1.Selector `json:"podSubnetIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ProximityPlacementGroupID *string `json:"proximityPlacementGroupId,omitempty" tf:"proximity_placement_group_id,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// +kubebuilder:validation:Optional
	UltraSsdEnabled *bool `json:"ultraSsdEnabled,omitempty" tf:"ultra_ssd_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	UpgradeSettings []UpgradeSettingsParameters `json:"upgradeSettings,omitempty" tf:"upgrade_settings,omitempty"`

	// +kubebuilder:validation:Required
	VMSize *string `json:"vmSize" tf:"vm_size,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-azure/apis/network/v1beta1.Subnet
	// +crossplane:generate:reference:extractor=github.com/upbound/official-providers/provider-azure/apis/rconfig.ExtractResourceID()
	// +kubebuilder:validation:Optional
	VnetSubnetID *string `json:"vnetSubnetId,omitempty" tf:"vnet_subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	VnetSubnetIDRef *v1.Reference `json:"vnetSubnetIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	VnetSubnetIDSelector *v1.Selector `json:"vnetSubnetIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Zones []*string `json:"zones,omitempty" tf:"zones,omitempty"`
}

type HTTPProxyConfigObservation struct {
}

type HTTPProxyConfigParameters struct {

	// +kubebuilder:validation:Optional
	HTTPProxy *string `json:"httpProxy,omitempty" tf:"http_proxy,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPSProxy *string `json:"httpsProxy,omitempty" tf:"https_proxy,omitempty"`

	// +kubebuilder:validation:Optional
	NoProxy []*string `json:"noProxy,omitempty" tf:"no_proxy,omitempty"`

	// +kubebuilder:validation:Optional
	TrustedCASecretRef *v1.SecretKeySelector `json:"trustedCaSecretRef,omitempty" tf:"-"`
}

type IdentityObservation struct {
	PrincipalID *string `json:"principalId,omitempty" tf:"principal_id,omitempty"`

	TenantID *string `json:"tenantId,omitempty" tf:"tenant_id,omitempty"`
}

type IdentityParameters struct {

	// +kubebuilder:validation:Optional
	IdentityIds []*string `json:"identityIds,omitempty" tf:"identity_ids,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type IngressApplicationGatewayIdentityObservation struct {
	ClientID *string `json:"clientId,omitempty" tf:"client_id,omitempty"`

	ObjectID *string `json:"objectId,omitempty" tf:"object_id,omitempty"`

	UserAssignedIdentityID *string `json:"userAssignedIdentityId,omitempty" tf:"user_assigned_identity_id,omitempty"`
}

type IngressApplicationGatewayIdentityParameters struct {
}

type IngressApplicationGatewayObservation struct {
	EffectiveGatewayID *string `json:"effectiveGatewayId,omitempty" tf:"effective_gateway_id,omitempty"`

	IngressApplicationGatewayIdentity []IngressApplicationGatewayIdentityObservation `json:"ingressApplicationGatewayIdentity,omitempty" tf:"ingress_application_gateway_identity,omitempty"`
}

type IngressApplicationGatewayParameters struct {

	// +kubebuilder:validation:Optional
	GatewayID *string `json:"gatewayId,omitempty" tf:"gateway_id,omitempty"`

	// +kubebuilder:validation:Optional
	GatewayName *string `json:"gatewayName,omitempty" tf:"gateway_name,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetCidr *string `json:"subnetCidr,omitempty" tf:"subnet_cidr,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-azure/apis/network/v1beta1.Subnet
	// +crossplane:generate:reference:extractor=github.com/upbound/official-providers/provider-azure/apis/rconfig.ExtractResourceID()
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetIDRef *v1.Reference `json:"subnetIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	SubnetIDSelector *v1.Selector `json:"subnetIdSelector,omitempty" tf:"-"`
}

type KeyVaultSecretsProviderObservation struct {
	SecretIdentity []SecretIdentityObservation `json:"secretIdentity,omitempty" tf:"secret_identity,omitempty"`
}

type KeyVaultSecretsProviderParameters struct {

	// +kubebuilder:validation:Optional
	SecretRotationEnabled *bool `json:"secretRotationEnabled,omitempty" tf:"secret_rotation_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	SecretRotationInterval *string `json:"secretRotationInterval,omitempty" tf:"secret_rotation_interval,omitempty"`
}

type KubeAdminConfigObservation struct {
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	Username *string `json:"username,omitempty" tf:"username,omitempty"`
}

type KubeAdminConfigParameters struct {
}

type KubeConfigObservation struct {
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	Username *string `json:"username,omitempty" tf:"username,omitempty"`
}

type KubeConfigParameters struct {
}

type KubeletConfigObservation struct {
}

type KubeletConfigParameters struct {

	// +kubebuilder:validation:Optional
	AllowedUnsafeSysctls []*string `json:"allowedUnsafeSysctls,omitempty" tf:"allowed_unsafe_sysctls,omitempty"`

	// +kubebuilder:validation:Optional
	CPUCfsQuotaEnabled *bool `json:"cpuCfsQuotaEnabled,omitempty" tf:"cpu_cfs_quota_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	CPUCfsQuotaPeriod *string `json:"cpuCfsQuotaPeriod,omitempty" tf:"cpu_cfs_quota_period,omitempty"`

	// +kubebuilder:validation:Optional
	CPUManagerPolicy *string `json:"cpuManagerPolicy,omitempty" tf:"cpu_manager_policy,omitempty"`

	// +kubebuilder:validation:Optional
	ContainerLogMaxLine *float64 `json:"containerLogMaxLine,omitempty" tf:"container_log_max_line,omitempty"`

	// +kubebuilder:validation:Optional
	ContainerLogMaxSizeMb *float64 `json:"containerLogMaxSizeMb,omitempty" tf:"container_log_max_size_mb,omitempty"`

	// +kubebuilder:validation:Optional
	ImageGcHighThreshold *float64 `json:"imageGcHighThreshold,omitempty" tf:"image_gc_high_threshold,omitempty"`

	// +kubebuilder:validation:Optional
	ImageGcLowThreshold *float64 `json:"imageGcLowThreshold,omitempty" tf:"image_gc_low_threshold,omitempty"`

	// +kubebuilder:validation:Optional
	PodMaxPid *float64 `json:"podMaxPid,omitempty" tf:"pod_max_pid,omitempty"`

	// +kubebuilder:validation:Optional
	TopologyManagerPolicy *string `json:"topologyManagerPolicy,omitempty" tf:"topology_manager_policy,omitempty"`
}

type KubeletIdentityObservation struct {
}

type KubeletIdentityParameters struct {

	// +kubebuilder:validation:Optional
	ClientID *string `json:"clientId,omitempty" tf:"client_id,omitempty"`

	// +kubebuilder:validation:Optional
	ObjectID *string `json:"objectId,omitempty" tf:"object_id,omitempty"`

	// +kubebuilder:validation:Optional
	UserAssignedIdentityID *string `json:"userAssignedIdentityId,omitempty" tf:"user_assigned_identity_id,omitempty"`
}

type KubernetesClusterObservation struct {
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`

	HTTPApplicationRoutingZoneName *string `json:"httpApplicationRoutingZoneName,omitempty" tf:"http_application_routing_zone_name,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Identity []IdentityObservation `json:"identity,omitempty" tf:"identity,omitempty"`

	IngressApplicationGateway []IngressApplicationGatewayObservation `json:"ingressApplicationGateway,omitempty" tf:"ingress_application_gateway,omitempty"`

	KeyVaultSecretsProvider []KeyVaultSecretsProviderObservation `json:"keyVaultSecretsProvider,omitempty" tf:"key_vault_secrets_provider,omitempty"`

	NetworkProfile []NetworkProfileObservation `json:"networkProfile,omitempty" tf:"network_profile,omitempty"`

	OidcIssuerURL *string `json:"oidcIssuerUrl,omitempty" tf:"oidc_issuer_url,omitempty"`

	OmsAgent []OmsAgentObservation `json:"omsAgent,omitempty" tf:"oms_agent,omitempty"`

	PortalFqdn *string `json:"portalFqdn,omitempty" tf:"portal_fqdn,omitempty"`

	PrivateFqdn *string `json:"privateFqdn,omitempty" tf:"private_fqdn,omitempty"`
}

type KubernetesClusterParameters struct {

	// +kubebuilder:validation:Optional
	APIServerAuthorizedIPRanges []*string `json:"apiServerAuthorizedIpRanges,omitempty" tf:"api_server_authorized_ip_ranges,omitempty"`

	// +kubebuilder:validation:Optional
	AciConnectorLinux []AciConnectorLinuxParameters `json:"aciConnectorLinux,omitempty" tf:"aci_connector_linux,omitempty"`

	// +kubebuilder:validation:Optional
	AutoScalerProfile []AutoScalerProfileParameters `json:"autoScalerProfile,omitempty" tf:"auto_scaler_profile,omitempty"`

	// +kubebuilder:validation:Optional
	AutomaticChannelUpgrade *string `json:"automaticChannelUpgrade,omitempty" tf:"automatic_channel_upgrade,omitempty"`

	// +kubebuilder:validation:Optional
	AzureActiveDirectoryRoleBasedAccessControl []AzureActiveDirectoryRoleBasedAccessControlParameters `json:"azureActiveDirectoryRoleBasedAccessControl,omitempty" tf:"azure_active_directory_role_based_access_control,omitempty"`

	// +kubebuilder:validation:Optional
	AzurePolicyEnabled *bool `json:"azurePolicyEnabled,omitempty" tf:"azure_policy_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	DNSPrefix *string `json:"dnsPrefix,omitempty" tf:"dns_prefix,omitempty"`

	// +kubebuilder:validation:Optional
	DNSPrefixPrivateCluster *string `json:"dnsPrefixPrivateCluster,omitempty" tf:"dns_prefix_private_cluster,omitempty"`

	// +kubebuilder:validation:Required
	DefaultNodePool []DefaultNodePoolParameters `json:"defaultNodePool" tf:"default_node_pool,omitempty"`

	// +kubebuilder:validation:Optional
	DiskEncryptionSetID *string `json:"diskEncryptionSetId,omitempty" tf:"disk_encryption_set_id,omitempty"`

	// +kubebuilder:validation:Optional
	EnablePodSecurityPolicy *bool `json:"enablePodSecurityPolicy,omitempty" tf:"enable_pod_security_policy,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPApplicationRoutingEnabled *bool `json:"httpApplicationRoutingEnabled,omitempty" tf:"http_application_routing_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPProxyConfig []HTTPProxyConfigParameters `json:"httpProxyConfig,omitempty" tf:"http_proxy_config,omitempty"`

	// +kubebuilder:validation:Optional
	Identity []IdentityParameters `json:"identity,omitempty" tf:"identity,omitempty"`

	// +kubebuilder:validation:Optional
	IngressApplicationGateway []IngressApplicationGatewayParameters `json:"ingressApplicationGateway,omitempty" tf:"ingress_application_gateway,omitempty"`

	// +kubebuilder:validation:Optional
	KeyVaultSecretsProvider []KeyVaultSecretsProviderParameters `json:"keyVaultSecretsProvider,omitempty" tf:"key_vault_secrets_provider,omitempty"`

	// +kubebuilder:validation:Optional
	KubeletIdentity []KubeletIdentityParameters `json:"kubeletIdentity,omitempty" tf:"kubelet_identity,omitempty"`

	// +kubebuilder:validation:Optional
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// +kubebuilder:validation:Optional
	LinuxProfile []LinuxProfileParameters `json:"linuxProfile,omitempty" tf:"linux_profile,omitempty"`

	// +kubebuilder:validation:Optional
	LocalAccountDisabled *bool `json:"localAccountDisabled,omitempty" tf:"local_account_disabled,omitempty"`

	// +kubebuilder:validation:Required
	Location *string `json:"location" tf:"location,omitempty"`

	// +kubebuilder:validation:Optional
	MaintenanceWindow []MaintenanceWindowParameters `json:"maintenanceWindow,omitempty" tf:"maintenance_window,omitempty"`

	// +kubebuilder:validation:Optional
	MicrosoftDefender []MicrosoftDefenderParameters `json:"microsoftDefender,omitempty" tf:"microsoft_defender,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkProfile []NetworkProfileParameters `json:"networkProfile,omitempty" tf:"network_profile,omitempty"`

	// +kubebuilder:validation:Optional
	NodeResourceGroup *string `json:"nodeResourceGroup,omitempty" tf:"node_resource_group,omitempty"`

	// +kubebuilder:validation:Optional
	OidcIssuerEnabled *bool `json:"oidcIssuerEnabled,omitempty" tf:"oidc_issuer_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	OmsAgent []OmsAgentParameters `json:"omsAgent,omitempty" tf:"oms_agent,omitempty"`

	// +kubebuilder:validation:Optional
	OpenServiceMeshEnabled *bool `json:"openServiceMeshEnabled,omitempty" tf:"open_service_mesh_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	PrivateClusterEnabled *bool `json:"privateClusterEnabled,omitempty" tf:"private_cluster_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	PrivateClusterPublicFqdnEnabled *bool `json:"privateClusterPublicFqdnEnabled,omitempty" tf:"private_cluster_public_fqdn_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	PrivateDNSZoneID *string `json:"privateDnsZoneId,omitempty" tf:"private_dns_zone_id,omitempty"`

	// +kubebuilder:validation:Optional
	PublicNetworkAccessEnabled *bool `json:"publicNetworkAccessEnabled,omitempty" tf:"public_network_access_enabled,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-azure/apis/azure/v1beta1.ResourceGroup
	// +kubebuilder:validation:Optional
	ResourceGroupName *string `json:"resourceGroupName,omitempty" tf:"resource_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceGroupNameRef *v1.Reference `json:"resourceGroupNameRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ResourceGroupNameSelector *v1.Selector `json:"resourceGroupNameSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	RoleBasedAccessControlEnabled *bool `json:"roleBasedAccessControlEnabled,omitempty" tf:"role_based_access_control_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	RunCommandEnabled *bool `json:"runCommandEnabled,omitempty" tf:"run_command_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	ServicePrincipal []ServicePrincipalParameters `json:"servicePrincipal,omitempty" tf:"service_principal,omitempty"`

	// +kubebuilder:validation:Optional
	SkuTier *string `json:"skuTier,omitempty" tf:"sku_tier,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	WindowsProfile []WindowsProfileParameters `json:"windowsProfile,omitempty" tf:"windows_profile,omitempty"`
}

type LinuxOsConfigObservation struct {
}

type LinuxOsConfigParameters struct {

	// +kubebuilder:validation:Optional
	SwapFileSizeMb *float64 `json:"swapFileSizeMb,omitempty" tf:"swap_file_size_mb,omitempty"`

	// +kubebuilder:validation:Optional
	SysctlConfig []SysctlConfigParameters `json:"sysctlConfig,omitempty" tf:"sysctl_config,omitempty"`

	// +kubebuilder:validation:Optional
	TransparentHugePageDefrag *string `json:"transparentHugePageDefrag,omitempty" tf:"transparent_huge_page_defrag,omitempty"`

	// +kubebuilder:validation:Optional
	TransparentHugePageEnabled *string `json:"transparentHugePageEnabled,omitempty" tf:"transparent_huge_page_enabled,omitempty"`
}

type LinuxProfileObservation struct {
}

type LinuxProfileParameters struct {

	// +kubebuilder:validation:Required
	AdminUsername *string `json:"adminUsername" tf:"admin_username,omitempty"`

	// +kubebuilder:validation:Required
	SSHKey []SSHKeyParameters `json:"sshKey" tf:"ssh_key,omitempty"`
}

type LoadBalancerProfileObservation struct {
	EffectiveOutboundIps []*string `json:"effectiveOutboundIps,omitempty" tf:"effective_outbound_ips,omitempty"`
}

type LoadBalancerProfileParameters struct {

	// +kubebuilder:validation:Optional
	IdleTimeoutInMinutes *float64 `json:"idleTimeoutInMinutes,omitempty" tf:"idle_timeout_in_minutes,omitempty"`

	// +kubebuilder:validation:Optional
	ManagedOutboundIPCount *float64 `json:"managedOutboundIpCount,omitempty" tf:"managed_outbound_ip_count,omitempty"`

	// +kubebuilder:validation:Optional
	OutboundIPAddressIds []*string `json:"outboundIpAddressIds,omitempty" tf:"outbound_ip_address_ids,omitempty"`

	// +kubebuilder:validation:Optional
	OutboundIPPrefixIds []*string `json:"outboundIpPrefixIds,omitempty" tf:"outbound_ip_prefix_ids,omitempty"`

	// +kubebuilder:validation:Optional
	OutboundPortsAllocated *float64 `json:"outboundPortsAllocated,omitempty" tf:"outbound_ports_allocated,omitempty"`
}

type MaintenanceWindowObservation struct {
}

type MaintenanceWindowParameters struct {

	// +kubebuilder:validation:Optional
	Allowed []AllowedParameters `json:"allowed,omitempty" tf:"allowed,omitempty"`

	// +kubebuilder:validation:Optional
	NotAllowed []NotAllowedParameters `json:"notAllowed,omitempty" tf:"not_allowed,omitempty"`
}

type MicrosoftDefenderObservation struct {
}

type MicrosoftDefenderParameters struct {

	// +kubebuilder:validation:Required
	LogAnalyticsWorkspaceID *string `json:"logAnalyticsWorkspaceId" tf:"log_analytics_workspace_id,omitempty"`
}

type NATGatewayProfileObservation struct {
	EffectiveOutboundIps []*string `json:"effectiveOutboundIps,omitempty" tf:"effective_outbound_ips,omitempty"`
}

type NATGatewayProfileParameters struct {

	// +kubebuilder:validation:Optional
	IdleTimeoutInMinutes *float64 `json:"idleTimeoutInMinutes,omitempty" tf:"idle_timeout_in_minutes,omitempty"`

	// +kubebuilder:validation:Optional
	ManagedOutboundIPCount *float64 `json:"managedOutboundIpCount,omitempty" tf:"managed_outbound_ip_count,omitempty"`
}

type NetworkProfileObservation struct {
	LoadBalancerProfile []LoadBalancerProfileObservation `json:"loadBalancerProfile,omitempty" tf:"load_balancer_profile,omitempty"`

	NATGatewayProfile []NATGatewayProfileObservation `json:"natGatewayProfile,omitempty" tf:"nat_gateway_profile,omitempty"`
}

type NetworkProfileParameters struct {

	// +kubebuilder:validation:Optional
	DNSServiceIP *string `json:"dnsServiceIp,omitempty" tf:"dns_service_ip,omitempty"`

	// +kubebuilder:validation:Optional
	DockerBridgeCidr *string `json:"dockerBridgeCidr,omitempty" tf:"docker_bridge_cidr,omitempty"`

	// +kubebuilder:validation:Optional
	IPVersions []*string `json:"ipVersions,omitempty" tf:"ip_versions,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancerProfile []LoadBalancerProfileParameters `json:"loadBalancerProfile,omitempty" tf:"load_balancer_profile,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancerSku *string `json:"loadBalancerSku,omitempty" tf:"load_balancer_sku,omitempty"`

	// +kubebuilder:validation:Optional
	NATGatewayProfile []NATGatewayProfileParameters `json:"natGatewayProfile,omitempty" tf:"nat_gateway_profile,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkMode *string `json:"networkMode,omitempty" tf:"network_mode,omitempty"`

	// +kubebuilder:validation:Required
	NetworkPlugin *string `json:"networkPlugin" tf:"network_plugin,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkPolicy *string `json:"networkPolicy,omitempty" tf:"network_policy,omitempty"`

	// +kubebuilder:validation:Optional
	OutboundType *string `json:"outboundType,omitempty" tf:"outbound_type,omitempty"`

	// +kubebuilder:validation:Optional
	PodCidr *string `json:"podCidr,omitempty" tf:"pod_cidr,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceCidr *string `json:"serviceCidr,omitempty" tf:"service_cidr,omitempty"`
}

type NotAllowedObservation struct {
}

type NotAllowedParameters struct {

	// +kubebuilder:validation:Required
	End *string `json:"end" tf:"end,omitempty"`

	// +kubebuilder:validation:Required
	Start *string `json:"start" tf:"start,omitempty"`
}

type OmsAgentIdentityObservation struct {
	ClientID *string `json:"clientId,omitempty" tf:"client_id,omitempty"`

	ObjectID *string `json:"objectId,omitempty" tf:"object_id,omitempty"`

	UserAssignedIdentityID *string `json:"userAssignedIdentityId,omitempty" tf:"user_assigned_identity_id,omitempty"`
}

type OmsAgentIdentityParameters struct {
}

type OmsAgentObservation struct {
	OmsAgentIdentity []OmsAgentIdentityObservation `json:"omsAgentIdentity,omitempty" tf:"oms_agent_identity,omitempty"`
}

type OmsAgentParameters struct {

	// +kubebuilder:validation:Required
	LogAnalyticsWorkspaceID *string `json:"logAnalyticsWorkspaceId" tf:"log_analytics_workspace_id,omitempty"`
}

type SSHKeyObservation struct {
}

type SSHKeyParameters struct {

	// +kubebuilder:validation:Required
	KeyData *string `json:"keyData" tf:"key_data,omitempty"`
}

type SecretIdentityObservation struct {
	ClientID *string `json:"clientId,omitempty" tf:"client_id,omitempty"`

	ObjectID *string `json:"objectId,omitempty" tf:"object_id,omitempty"`

	UserAssignedIdentityID *string `json:"userAssignedIdentityId,omitempty" tf:"user_assigned_identity_id,omitempty"`
}

type SecretIdentityParameters struct {
}

type ServicePrincipalObservation struct {
}

type ServicePrincipalParameters struct {

	// +kubebuilder:validation:Required
	ClientID *string `json:"clientId" tf:"client_id,omitempty"`

	// +kubebuilder:validation:Required
	ClientSecretSecretRef v1.SecretKeySelector `json:"clientSecretSecretRef" tf:"-"`
}

type SysctlConfigObservation struct {
}

type SysctlConfigParameters struct {

	// +kubebuilder:validation:Optional
	FsAioMaxNr *float64 `json:"fsAioMaxNr,omitempty" tf:"fs_aio_max_nr,omitempty"`

	// +kubebuilder:validation:Optional
	FsFileMax *float64 `json:"fsFileMax,omitempty" tf:"fs_file_max,omitempty"`

	// +kubebuilder:validation:Optional
	FsInotifyMaxUserWatches *float64 `json:"fsInotifyMaxUserWatches,omitempty" tf:"fs_inotify_max_user_watches,omitempty"`

	// +kubebuilder:validation:Optional
	FsNrOpen *float64 `json:"fsNrOpen,omitempty" tf:"fs_nr_open,omitempty"`

	// +kubebuilder:validation:Optional
	KernelThreadsMax *float64 `json:"kernelThreadsMax,omitempty" tf:"kernel_threads_max,omitempty"`

	// +kubebuilder:validation:Optional
	NetCoreNetdevMaxBacklog *float64 `json:"netCoreNetdevMaxBacklog,omitempty" tf:"net_core_netdev_max_backlog,omitempty"`

	// +kubebuilder:validation:Optional
	NetCoreOptmemMax *float64 `json:"netCoreOptmemMax,omitempty" tf:"net_core_optmem_max,omitempty"`

	// +kubebuilder:validation:Optional
	NetCoreRmemDefault *float64 `json:"netCoreRmemDefault,omitempty" tf:"net_core_rmem_default,omitempty"`

	// +kubebuilder:validation:Optional
	NetCoreRmemMax *float64 `json:"netCoreRmemMax,omitempty" tf:"net_core_rmem_max,omitempty"`

	// +kubebuilder:validation:Optional
	NetCoreSomaxconn *float64 `json:"netCoreSomaxconn,omitempty" tf:"net_core_somaxconn,omitempty"`

	// +kubebuilder:validation:Optional
	NetCoreWmemDefault *float64 `json:"netCoreWmemDefault,omitempty" tf:"net_core_wmem_default,omitempty"`

	// +kubebuilder:validation:Optional
	NetCoreWmemMax *float64 `json:"netCoreWmemMax,omitempty" tf:"net_core_wmem_max,omitempty"`

	// +kubebuilder:validation:Optional
	NetIPv4IPLocalPortRangeMax *float64 `json:"netIpv4IpLocalPortRangeMax,omitempty" tf:"net_ipv4_ip_local_port_range_max,omitempty"`

	// +kubebuilder:validation:Optional
	NetIPv4IPLocalPortRangeMin *float64 `json:"netIpv4IpLocalPortRangeMin,omitempty" tf:"net_ipv4_ip_local_port_range_min,omitempty"`

	// +kubebuilder:validation:Optional
	NetIPv4NeighDefaultGcThresh1 *float64 `json:"netIpv4NeighDefaultGcThresh1,omitempty" tf:"net_ipv4_neigh_default_gc_thresh1,omitempty"`

	// +kubebuilder:validation:Optional
	NetIPv4NeighDefaultGcThresh2 *float64 `json:"netIpv4NeighDefaultGcThresh2,omitempty" tf:"net_ipv4_neigh_default_gc_thresh2,omitempty"`

	// +kubebuilder:validation:Optional
	NetIPv4NeighDefaultGcThresh3 *float64 `json:"netIpv4NeighDefaultGcThresh3,omitempty" tf:"net_ipv4_neigh_default_gc_thresh3,omitempty"`

	// +kubebuilder:validation:Optional
	NetIPv4TCPFinTimeout *float64 `json:"netIpv4TcpFinTimeout,omitempty" tf:"net_ipv4_tcp_fin_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	NetIPv4TCPKeepaliveIntvl *float64 `json:"netIpv4TcpKeepaliveIntvl,omitempty" tf:"net_ipv4_tcp_keepalive_intvl,omitempty"`

	// +kubebuilder:validation:Optional
	NetIPv4TCPKeepaliveProbes *float64 `json:"netIpv4TcpKeepaliveProbes,omitempty" tf:"net_ipv4_tcp_keepalive_probes,omitempty"`

	// +kubebuilder:validation:Optional
	NetIPv4TCPKeepaliveTime *float64 `json:"netIpv4TcpKeepaliveTime,omitempty" tf:"net_ipv4_tcp_keepalive_time,omitempty"`

	// +kubebuilder:validation:Optional
	NetIPv4TCPMaxSynBacklog *float64 `json:"netIpv4TcpMaxSynBacklog,omitempty" tf:"net_ipv4_tcp_max_syn_backlog,omitempty"`

	// +kubebuilder:validation:Optional
	NetIPv4TCPMaxTwBuckets *float64 `json:"netIpv4TcpMaxTwBuckets,omitempty" tf:"net_ipv4_tcp_max_tw_buckets,omitempty"`

	// +kubebuilder:validation:Optional
	NetIPv4TCPTwReuse *bool `json:"netIpv4TcpTwReuse,omitempty" tf:"net_ipv4_tcp_tw_reuse,omitempty"`

	// +kubebuilder:validation:Optional
	NetNetfilterNfConntrackBuckets *float64 `json:"netNetfilterNfConntrackBuckets,omitempty" tf:"net_netfilter_nf_conntrack_buckets,omitempty"`

	// +kubebuilder:validation:Optional
	NetNetfilterNfConntrackMax *float64 `json:"netNetfilterNfConntrackMax,omitempty" tf:"net_netfilter_nf_conntrack_max,omitempty"`

	// +kubebuilder:validation:Optional
	VMMaxMapCount *float64 `json:"vmMaxMapCount,omitempty" tf:"vm_max_map_count,omitempty"`

	// +kubebuilder:validation:Optional
	VMSwappiness *float64 `json:"vmSwappiness,omitempty" tf:"vm_swappiness,omitempty"`

	// +kubebuilder:validation:Optional
	VMVfsCachePressure *float64 `json:"vmVfsCachePressure,omitempty" tf:"vm_vfs_cache_pressure,omitempty"`
}

type UpgradeSettingsObservation struct {
}

type UpgradeSettingsParameters struct {

	// +kubebuilder:validation:Required
	MaxSurge *string `json:"maxSurge" tf:"max_surge,omitempty"`
}

type WindowsProfileObservation struct {
}

type WindowsProfileParameters struct {

	// +kubebuilder:validation:Optional
	AdminPasswordSecretRef *v1.SecretKeySelector `json:"adminPasswordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	AdminUsername *string `json:"adminUsername" tf:"admin_username,omitempty"`

	// +kubebuilder:validation:Optional
	License *string `json:"license,omitempty" tf:"license,omitempty"`
}

// KubernetesClusterSpec defines the desired state of KubernetesCluster
type KubernetesClusterSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     KubernetesClusterParameters `json:"forProvider"`
}

// KubernetesClusterStatus defines the observed state of KubernetesCluster.
type KubernetesClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        KubernetesClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// KubernetesCluster is the Schema for the KubernetesClusters API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type KubernetesCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              KubernetesClusterSpec   `json:"spec"`
	Status            KubernetesClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// KubernetesClusterList contains a list of KubernetesClusters
type KubernetesClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []KubernetesCluster `json:"items"`
}

// Repository type metadata.
var (
	KubernetesCluster_Kind             = "KubernetesCluster"
	KubernetesCluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: KubernetesCluster_Kind}.String()
	KubernetesCluster_KindAPIVersion   = KubernetesCluster_Kind + "." + CRDGroupVersion.String()
	KubernetesCluster_GroupVersionKind = CRDGroupVersion.WithKind(KubernetesCluster_Kind)
)

func init() {
	SchemeBuilder.Register(&KubernetesCluster{}, &KubernetesClusterList{})
}
