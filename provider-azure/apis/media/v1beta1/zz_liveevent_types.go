/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CrossSiteAccessPolicyObservation struct {
}

type CrossSiteAccessPolicyParameters struct {

	// +kubebuilder:validation:Optional
	ClientAccessPolicy *string `json:"clientAccessPolicy,omitempty" tf:"client_access_policy,omitempty"`

	// +kubebuilder:validation:Optional
	CrossDomainPolicy *string `json:"crossDomainPolicy,omitempty" tf:"cross_domain_policy,omitempty"`
}

type EncodingObservation struct {
}

type EncodingParameters struct {

	// +kubebuilder:validation:Optional
	KeyFrameInterval *string `json:"keyFrameInterval,omitempty" tf:"key_frame_interval,omitempty"`

	// +kubebuilder:validation:Optional
	PresetName *string `json:"presetName,omitempty" tf:"preset_name,omitempty"`

	// +kubebuilder:validation:Optional
	StretchMode *string `json:"stretchMode,omitempty" tf:"stretch_mode,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type EndpointObservation struct {
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type EndpointParameters struct {
}

type IPAccessControlAllowObservation struct {
}

type IPAccessControlAllowParameters struct {

	// +kubebuilder:validation:Optional
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetPrefixLength *float64 `json:"subnetPrefixLength,omitempty" tf:"subnet_prefix_length,omitempty"`
}

type InputObservation struct {
	Endpoint []EndpointObservation `json:"endpoint,omitempty" tf:"endpoint,omitempty"`
}

type InputParameters struct {

	// +kubebuilder:validation:Optional
	AccessToken *string `json:"accessToken,omitempty" tf:"access_token,omitempty"`

	// +kubebuilder:validation:Optional
	IPAccessControlAllow []IPAccessControlAllowParameters `json:"ipAccessControlAllow,omitempty" tf:"ip_access_control_allow,omitempty"`

	// +kubebuilder:validation:Optional
	KeyFrameIntervalDuration *string `json:"keyFrameIntervalDuration,omitempty" tf:"key_frame_interval_duration,omitempty"`

	// +kubebuilder:validation:Optional
	StreamingProtocol *string `json:"streamingProtocol,omitempty" tf:"streaming_protocol,omitempty"`
}

type LiveEventObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Input []InputObservation `json:"input,omitempty" tf:"input,omitempty"`

	Preview []PreviewObservation `json:"preview,omitempty" tf:"preview,omitempty"`
}

type LiveEventParameters struct {

	// +kubebuilder:validation:Optional
	AutoStartEnabled *bool `json:"autoStartEnabled,omitempty" tf:"auto_start_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	CrossSiteAccessPolicy []CrossSiteAccessPolicyParameters `json:"crossSiteAccessPolicy,omitempty" tf:"cross_site_access_policy,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	Encoding []EncodingParameters `json:"encoding,omitempty" tf:"encoding,omitempty"`

	// +kubebuilder:validation:Optional
	HostNamePrefix *string `json:"hostnamePrefix,omitempty" tf:"hostname_prefix,omitempty"`

	// +kubebuilder:validation:Required
	Input []InputParameters `json:"input" tf:"input,omitempty"`

	// +kubebuilder:validation:Required
	Location *string `json:"location" tf:"location,omitempty"`

	// +crossplane:generate:reference:type=ServicesAccount
	// +kubebuilder:validation:Optional
	MediaServicesAccountName *string `json:"mediaServicesAccountName,omitempty" tf:"media_services_account_name,omitempty"`

	// +kubebuilder:validation:Optional
	MediaServicesAccountNameRef *v1.Reference `json:"mediaServicesAccountNameRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	MediaServicesAccountNameSelector *v1.Selector `json:"mediaServicesAccountNameSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Preview []PreviewParameters `json:"preview,omitempty" tf:"preview,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-azure/apis/azure/v1beta1.ResourceGroup
	// +kubebuilder:validation:Optional
	ResourceGroupName *string `json:"resourceGroupName,omitempty" tf:"resource_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceGroupNameRef *v1.Reference `json:"resourceGroupNameRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ResourceGroupNameSelector *v1.Selector `json:"resourceGroupNameSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	TranscriptionLanguages []*string `json:"transcriptionLanguages,omitempty" tf:"transcription_languages,omitempty"`

	// +kubebuilder:validation:Optional
	UseStaticHostName *bool `json:"useStaticHostname,omitempty" tf:"use_static_hostname,omitempty"`
}

type PreviewEndpointObservation struct {
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type PreviewEndpointParameters struct {
}

type PreviewIPAccessControlAllowObservation struct {
}

type PreviewIPAccessControlAllowParameters struct {

	// +kubebuilder:validation:Optional
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetPrefixLength *float64 `json:"subnetPrefixLength,omitempty" tf:"subnet_prefix_length,omitempty"`
}

type PreviewObservation struct {
	Endpoint []PreviewEndpointObservation `json:"endpoint,omitempty" tf:"endpoint,omitempty"`
}

type PreviewParameters struct {

	// +kubebuilder:validation:Optional
	AlternativeMediaID *string `json:"alternativeMediaId,omitempty" tf:"alternative_media_id,omitempty"`

	// +kubebuilder:validation:Optional
	IPAccessControlAllow []PreviewIPAccessControlAllowParameters `json:"ipAccessControlAllow,omitempty" tf:"ip_access_control_allow,omitempty"`

	// +kubebuilder:validation:Optional
	PreviewLocator *string `json:"previewLocator,omitempty" tf:"preview_locator,omitempty"`

	// +kubebuilder:validation:Optional
	StreamingPolicyName *string `json:"streamingPolicyName,omitempty" tf:"streaming_policy_name,omitempty"`
}

// LiveEventSpec defines the desired state of LiveEvent
type LiveEventSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     LiveEventParameters `json:"forProvider"`
}

// LiveEventStatus defines the observed state of LiveEvent.
type LiveEventStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        LiveEventObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// LiveEvent is the Schema for the LiveEvents API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type LiveEvent struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LiveEventSpec   `json:"spec"`
	Status            LiveEventStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// LiveEventList contains a list of LiveEvents
type LiveEventList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LiveEvent `json:"items"`
}

// Repository type metadata.
var (
	LiveEvent_Kind             = "LiveEvent"
	LiveEvent_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: LiveEvent_Kind}.String()
	LiveEvent_KindAPIVersion   = LiveEvent_Kind + "." + CRDGroupVersion.String()
	LiveEvent_GroupVersionKind = CRDGroupVersion.WithKind(LiveEvent_Kind)
)

func init() {
	SchemeBuilder.Register(&LiveEvent{}, &LiveEventList{})
}
