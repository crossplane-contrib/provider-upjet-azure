/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CommonEncryptionCbcsObservation struct {
}

type CommonEncryptionCbcsParameters struct {

	// +kubebuilder:validation:Optional
	DefaultContentKey []DefaultContentKeyParameters `json:"defaultContentKey,omitempty" tf:"default_content_key,omitempty"`

	// +kubebuilder:validation:Optional
	DrmFairplay []DrmFairplayParameters `json:"drmFairplay,omitempty" tf:"drm_fairplay,omitempty"`

	// +kubebuilder:validation:Optional
	EnabledProtocols []EnabledProtocolsParameters `json:"enabledProtocols,omitempty" tf:"enabled_protocols,omitempty"`
}

type CommonEncryptionCencDefaultContentKeyObservation struct {
}

type CommonEncryptionCencDefaultContentKeyParameters struct {

	// +kubebuilder:validation:Optional
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// +kubebuilder:validation:Optional
	PolicyName *string `json:"policyName,omitempty" tf:"policy_name,omitempty"`
}

type CommonEncryptionCencEnabledProtocolsObservation struct {
}

type CommonEncryptionCencEnabledProtocolsParameters struct {

	// +kubebuilder:validation:Optional
	Dash *bool `json:"dash,omitempty" tf:"dash,omitempty"`

	// +kubebuilder:validation:Optional
	Download *bool `json:"download,omitempty" tf:"download,omitempty"`

	// +kubebuilder:validation:Optional
	Hls *bool `json:"hls,omitempty" tf:"hls,omitempty"`

	// +kubebuilder:validation:Optional
	SmoothStreaming *bool `json:"smoothStreaming,omitempty" tf:"smooth_streaming,omitempty"`
}

type CommonEncryptionCencObservation struct {
}

type CommonEncryptionCencParameters struct {

	// +kubebuilder:validation:Optional
	DefaultContentKey []CommonEncryptionCencDefaultContentKeyParameters `json:"defaultContentKey,omitempty" tf:"default_content_key,omitempty"`

	// +kubebuilder:validation:Optional
	DrmPlayready []DrmPlayreadyParameters `json:"drmPlayready,omitempty" tf:"drm_playready,omitempty"`

	// +kubebuilder:validation:Optional
	DrmWidevineCustomLicenseAcquisitionURLTemplate *string `json:"drmWidevineCustomLicenseAcquisitionUrlTemplate,omitempty" tf:"drm_widevine_custom_license_acquisition_url_template,omitempty"`

	// +kubebuilder:validation:Optional
	EnabledProtocols []CommonEncryptionCencEnabledProtocolsParameters `json:"enabledProtocols,omitempty" tf:"enabled_protocols,omitempty"`
}

type DefaultContentKeyObservation struct {
}

type DefaultContentKeyParameters struct {

	// +kubebuilder:validation:Optional
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// +kubebuilder:validation:Optional
	PolicyName *string `json:"policyName,omitempty" tf:"policy_name,omitempty"`
}

type DrmFairplayObservation struct {
}

type DrmFairplayParameters struct {

	// +kubebuilder:validation:Optional
	AllowPersistentLicense *bool `json:"allowPersistentLicense,omitempty" tf:"allow_persistent_license,omitempty"`

	// +kubebuilder:validation:Optional
	CustomLicenseAcquisitionURLTemplate *string `json:"customLicenseAcquisitionUrlTemplate,omitempty" tf:"custom_license_acquisition_url_template,omitempty"`
}

type DrmPlayreadyObservation struct {
}

type DrmPlayreadyParameters struct {

	// +kubebuilder:validation:Optional
	CustomAttributes *string `json:"customAttributes,omitempty" tf:"custom_attributes,omitempty"`

	// +kubebuilder:validation:Optional
	CustomLicenseAcquisitionURLTemplate *string `json:"customLicenseAcquisitionUrlTemplate,omitempty" tf:"custom_license_acquisition_url_template,omitempty"`
}

type EnabledProtocolsObservation struct {
}

type EnabledProtocolsParameters struct {

	// +kubebuilder:validation:Optional
	Dash *bool `json:"dash,omitempty" tf:"dash,omitempty"`

	// +kubebuilder:validation:Optional
	Download *bool `json:"download,omitempty" tf:"download,omitempty"`

	// +kubebuilder:validation:Optional
	Hls *bool `json:"hls,omitempty" tf:"hls,omitempty"`

	// +kubebuilder:validation:Optional
	SmoothStreaming *bool `json:"smoothStreaming,omitempty" tf:"smooth_streaming,omitempty"`
}

type NoEncryptionEnabledProtocolsObservation struct {
}

type NoEncryptionEnabledProtocolsParameters struct {

	// +kubebuilder:validation:Optional
	Dash *bool `json:"dash,omitempty" tf:"dash,omitempty"`

	// +kubebuilder:validation:Optional
	Download *bool `json:"download,omitempty" tf:"download,omitempty"`

	// +kubebuilder:validation:Optional
	Hls *bool `json:"hls,omitempty" tf:"hls,omitempty"`

	// +kubebuilder:validation:Optional
	SmoothStreaming *bool `json:"smoothStreaming,omitempty" tf:"smooth_streaming,omitempty"`
}

type StreamingPolicyObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type StreamingPolicyParameters struct {

	// +kubebuilder:validation:Optional
	CommonEncryptionCbcs []CommonEncryptionCbcsParameters `json:"commonEncryptionCbcs,omitempty" tf:"common_encryption_cbcs,omitempty"`

	// +kubebuilder:validation:Optional
	CommonEncryptionCenc []CommonEncryptionCencParameters `json:"commonEncryptionCenc,omitempty" tf:"common_encryption_cenc,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultContentKeyPolicyName *string `json:"defaultContentKeyPolicyName,omitempty" tf:"default_content_key_policy_name,omitempty"`

	// +crossplane:generate:reference:type=ServicesAccount
	// +kubebuilder:validation:Optional
	MediaServicesAccountName *string `json:"mediaServicesAccountName,omitempty" tf:"media_services_account_name,omitempty"`

	// +kubebuilder:validation:Optional
	MediaServicesAccountNameRef *v1.Reference `json:"mediaServicesAccountNameRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	MediaServicesAccountNameSelector *v1.Selector `json:"mediaServicesAccountNameSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	NoEncryptionEnabledProtocols []NoEncryptionEnabledProtocolsParameters `json:"noEncryptionEnabledProtocols,omitempty" tf:"no_encryption_enabled_protocols,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-azure/apis/azure/v1beta1.ResourceGroup
	// +kubebuilder:validation:Optional
	ResourceGroupName *string `json:"resourceGroupName,omitempty" tf:"resource_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceGroupNameRef *v1.Reference `json:"resourceGroupNameRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ResourceGroupNameSelector *v1.Selector `json:"resourceGroupNameSelector,omitempty" tf:"-"`
}

// StreamingPolicySpec defines the desired state of StreamingPolicy
type StreamingPolicySpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     StreamingPolicyParameters `json:"forProvider"`
}

// StreamingPolicyStatus defines the observed state of StreamingPolicy.
type StreamingPolicyStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        StreamingPolicyObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// StreamingPolicy is the Schema for the StreamingPolicys API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type StreamingPolicy struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              StreamingPolicySpec   `json:"spec"`
	Status            StreamingPolicyStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// StreamingPolicyList contains a list of StreamingPolicys
type StreamingPolicyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []StreamingPolicy `json:"items"`
}

// Repository type metadata.
var (
	StreamingPolicy_Kind             = "StreamingPolicy"
	StreamingPolicy_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: StreamingPolicy_Kind}.String()
	StreamingPolicy_KindAPIVersion   = StreamingPolicy_Kind + "." + CRDGroupVersion.String()
	StreamingPolicy_GroupVersionKind = CRDGroupVersion.WithKind(StreamingPolicy_Kind)
)

func init() {
	SchemeBuilder.Register(&StreamingPolicy{}, &StreamingPolicyList{})
}
