/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type APIDiagnosticObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type APIDiagnosticParameters struct {

	// +kubebuilder:validation:Required
	APIManagementLoggerID *string `json:"apiManagementLoggerId" tf:"api_management_logger_id,omitempty"`

	// +kubebuilder:validation:Required
	APIManagementName *string `json:"apiManagementName" tf:"api_management_name,omitempty"`

	// +kubebuilder:validation:Required
	APIName *string `json:"apiName" tf:"api_name,omitempty"`

	// +kubebuilder:validation:Optional
	AlwaysLogErrors *bool `json:"alwaysLogErrors,omitempty" tf:"always_log_errors,omitempty"`

	// +kubebuilder:validation:Optional
	BackendRequest []BackendRequestParameters `json:"backendRequest,omitempty" tf:"backend_request,omitempty"`

	// +kubebuilder:validation:Optional
	BackendResponse []BackendResponseParameters `json:"backendResponse,omitempty" tf:"backend_response,omitempty"`

	// +kubebuilder:validation:Optional
	FrontendRequest []FrontendRequestParameters `json:"frontendRequest,omitempty" tf:"frontend_request,omitempty"`

	// +kubebuilder:validation:Optional
	FrontendResponse []FrontendResponseParameters `json:"frontendResponse,omitempty" tf:"frontend_response,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPCorrelationProtocol *string `json:"httpCorrelationProtocol,omitempty" tf:"http_correlation_protocol,omitempty"`

	// +kubebuilder:validation:Required
	Identifier *string `json:"identifier" tf:"identifier,omitempty"`

	// +kubebuilder:validation:Optional
	LogClientIP *bool `json:"logClientIp,omitempty" tf:"log_client_ip,omitempty"`

	// +kubebuilder:validation:Optional
	OperationNameFormat *string `json:"operationNameFormat,omitempty" tf:"operation_name_format,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-azure/apis/azure/v1beta1.ResourceGroup
	// +kubebuilder:validation:Optional
	ResourceGroupName *string `json:"resourceGroupName,omitempty" tf:"resource_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceGroupNameRef *v1.Reference `json:"resourceGroupNameRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ResourceGroupNameSelector *v1.Selector `json:"resourceGroupNameSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	SamplingPercentage *float64 `json:"samplingPercentage,omitempty" tf:"sampling_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	Verbosity *string `json:"verbosity,omitempty" tf:"verbosity,omitempty"`
}

type BackendRequestObservation struct {
}

type BackendRequestParameters struct {

	// +kubebuilder:validation:Optional
	BodyBytes *float64 `json:"bodyBytes,omitempty" tf:"body_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	DataMasking []DataMaskingParameters `json:"dataMasking,omitempty" tf:"data_masking,omitempty"`

	// +kubebuilder:validation:Optional
	HeadersToLog []*string `json:"headersToLog,omitempty" tf:"headers_to_log,omitempty"`
}

type BackendResponseDataMaskingObservation struct {
}

type BackendResponseDataMaskingParameters struct {

	// +kubebuilder:validation:Optional
	Headers []DataMaskingHeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// +kubebuilder:validation:Optional
	QueryParams []DataMaskingQueryParamsParameters `json:"queryParams,omitempty" tf:"query_params,omitempty"`
}

type BackendResponseObservation struct {
}

type BackendResponseParameters struct {

	// +kubebuilder:validation:Optional
	BodyBytes *float64 `json:"bodyBytes,omitempty" tf:"body_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	DataMasking []BackendResponseDataMaskingParameters `json:"dataMasking,omitempty" tf:"data_masking,omitempty"`

	// +kubebuilder:validation:Optional
	HeadersToLog []*string `json:"headersToLog,omitempty" tf:"headers_to_log,omitempty"`
}

type DataMaskingHeadersObservation struct {
}

type DataMaskingHeadersParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type DataMaskingObservation struct {
}

type DataMaskingParameters struct {

	// +kubebuilder:validation:Optional
	Headers []HeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// +kubebuilder:validation:Optional
	QueryParams []QueryParamsParameters `json:"queryParams,omitempty" tf:"query_params,omitempty"`
}

type DataMaskingQueryParamsObservation struct {
}

type DataMaskingQueryParamsParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type FrontendRequestDataMaskingHeadersObservation struct {
}

type FrontendRequestDataMaskingHeadersParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type FrontendRequestDataMaskingObservation struct {
}

type FrontendRequestDataMaskingParameters struct {

	// +kubebuilder:validation:Optional
	Headers []FrontendRequestDataMaskingHeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// +kubebuilder:validation:Optional
	QueryParams []FrontendRequestDataMaskingQueryParamsParameters `json:"queryParams,omitempty" tf:"query_params,omitempty"`
}

type FrontendRequestDataMaskingQueryParamsObservation struct {
}

type FrontendRequestDataMaskingQueryParamsParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type FrontendRequestObservation struct {
}

type FrontendRequestParameters struct {

	// +kubebuilder:validation:Optional
	BodyBytes *float64 `json:"bodyBytes,omitempty" tf:"body_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	DataMasking []FrontendRequestDataMaskingParameters `json:"dataMasking,omitempty" tf:"data_masking,omitempty"`

	// +kubebuilder:validation:Optional
	HeadersToLog []*string `json:"headersToLog,omitempty" tf:"headers_to_log,omitempty"`
}

type FrontendResponseDataMaskingHeadersObservation struct {
}

type FrontendResponseDataMaskingHeadersParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type FrontendResponseDataMaskingObservation struct {
}

type FrontendResponseDataMaskingParameters struct {

	// +kubebuilder:validation:Optional
	Headers []FrontendResponseDataMaskingHeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// +kubebuilder:validation:Optional
	QueryParams []FrontendResponseDataMaskingQueryParamsParameters `json:"queryParams,omitempty" tf:"query_params,omitempty"`
}

type FrontendResponseDataMaskingQueryParamsObservation struct {
}

type FrontendResponseDataMaskingQueryParamsParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type FrontendResponseObservation struct {
}

type FrontendResponseParameters struct {

	// +kubebuilder:validation:Optional
	BodyBytes *float64 `json:"bodyBytes,omitempty" tf:"body_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	DataMasking []FrontendResponseDataMaskingParameters `json:"dataMasking,omitempty" tf:"data_masking,omitempty"`

	// +kubebuilder:validation:Optional
	HeadersToLog []*string `json:"headersToLog,omitempty" tf:"headers_to_log,omitempty"`
}

type HeadersObservation struct {
}

type HeadersParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type QueryParamsObservation struct {
}

type QueryParamsParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

// APIDiagnosticSpec defines the desired state of APIDiagnostic
type APIDiagnosticSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     APIDiagnosticParameters `json:"forProvider"`
}

// APIDiagnosticStatus defines the observed state of APIDiagnostic.
type APIDiagnosticStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        APIDiagnosticObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// APIDiagnostic is the Schema for the APIDiagnostics API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type APIDiagnostic struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              APIDiagnosticSpec   `json:"spec"`
	Status            APIDiagnosticStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// APIDiagnosticList contains a list of APIDiagnostics
type APIDiagnosticList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []APIDiagnostic `json:"items"`
}

// Repository type metadata.
var (
	APIDiagnostic_Kind             = "APIDiagnostic"
	APIDiagnostic_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: APIDiagnostic_Kind}.String()
	APIDiagnostic_KindAPIVersion   = APIDiagnostic_Kind + "." + CRDGroupVersion.String()
	APIDiagnostic_GroupVersionKind = CRDGroupVersion.WithKind(APIDiagnostic_Kind)
)

func init() {
	SchemeBuilder.Register(&APIDiagnostic{}, &APIDiagnosticList{})
}
