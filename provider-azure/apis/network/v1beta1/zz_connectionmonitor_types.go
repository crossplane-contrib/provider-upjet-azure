/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ConnectionMonitorObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type ConnectionMonitorParameters struct {

	// +kubebuilder:validation:Required
	Endpoint []EndpointParameters `json:"endpoint" tf:"endpoint,omitempty"`

	// +kubebuilder:validation:Required
	Location *string `json:"location" tf:"location,omitempty"`

	// +crossplane:generate:reference:type=Watcher
	// +crossplane:generate:reference:extractor=github.com/upbound/official-providers/provider-azure/apis/rconfig.ExtractResourceID()
	// +kubebuilder:validation:Optional
	NetworkWatcherID *string `json:"networkWatcherId,omitempty" tf:"network_watcher_id,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkWatcherIDRef *v1.Reference `json:"networkWatcherIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	NetworkWatcherIDSelector *v1.Selector `json:"networkWatcherIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Notes *string `json:"notes,omitempty" tf:"notes,omitempty"`

	// +kubebuilder:validation:Optional
	OutputWorkspaceResourceIds []*string `json:"outputWorkspaceResourceIds,omitempty" tf:"output_workspace_resource_ids,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Required
	TestConfiguration []TestConfigurationParameters `json:"testConfiguration" tf:"test_configuration,omitempty"`

	// +kubebuilder:validation:Required
	TestGroup []TestGroupParameters `json:"testGroup" tf:"test_group,omitempty"`
}

type EndpointObservation struct {
}

type EndpointParameters struct {

	// +kubebuilder:validation:Optional
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// +kubebuilder:validation:Optional
	CoverageLevel *string `json:"coverageLevel,omitempty" tf:"coverage_level,omitempty"`

	// +kubebuilder:validation:Optional
	ExcludedIPAddresses []*string `json:"excludedIpAddresses,omitempty" tf:"excluded_ip_addresses,omitempty"`

	// +kubebuilder:validation:Optional
	Filter []FilterParameters `json:"filter,omitempty" tf:"filter,omitempty"`

	// +kubebuilder:validation:Optional
	IncludedIPAddresses []*string `json:"includedIpAddresses,omitempty" tf:"included_ip_addresses,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	TargetResourceID *string `json:"targetResourceId,omitempty" tf:"target_resource_id,omitempty"`

	// +kubebuilder:validation:Optional
	TargetResourceType *string `json:"targetResourceType,omitempty" tf:"target_resource_type,omitempty"`
}

type FilterObservation struct {
}

type FilterParameters struct {

	// +kubebuilder:validation:Optional
	Item []ItemParameters `json:"item,omitempty" tf:"item,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type HTTPConfigurationObservation struct {
}

type HTTPConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	PreferHTTPS *bool `json:"preferHttps,omitempty" tf:"prefer_https,omitempty"`

	// +kubebuilder:validation:Optional
	RequestHeader []RequestHeaderParameters `json:"requestHeader,omitempty" tf:"request_header,omitempty"`

	// +kubebuilder:validation:Optional
	ValidStatusCodeRanges []*string `json:"validStatusCodeRanges,omitempty" tf:"valid_status_code_ranges,omitempty"`
}

type IcmpConfigurationObservation struct {
}

type IcmpConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	TraceRouteEnabled *bool `json:"traceRouteEnabled,omitempty" tf:"trace_route_enabled,omitempty"`
}

type ItemObservation struct {
}

type ItemParameters struct {

	// +kubebuilder:validation:Optional
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type RequestHeaderObservation struct {
}

type RequestHeaderParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type SuccessThresholdObservation struct {
}

type SuccessThresholdParameters struct {

	// +kubebuilder:validation:Optional
	ChecksFailedPercent *float64 `json:"checksFailedPercent,omitempty" tf:"checks_failed_percent,omitempty"`

	// +kubebuilder:validation:Optional
	RoundTripTimeMS *float64 `json:"roundTripTimeMs,omitempty" tf:"round_trip_time_ms,omitempty"`
}

type TCPConfigurationObservation struct {
}

type TCPConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	DestinationPortBehavior *string `json:"destinationPortBehavior,omitempty" tf:"destination_port_behavior,omitempty"`

	// +kubebuilder:validation:Required
	Port *float64 `json:"port" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	TraceRouteEnabled *bool `json:"traceRouteEnabled,omitempty" tf:"trace_route_enabled,omitempty"`
}

type TestConfigurationObservation struct {
}

type TestConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	HTTPConfiguration []HTTPConfigurationParameters `json:"httpConfiguration,omitempty" tf:"http_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	IcmpConfiguration []IcmpConfigurationParameters `json:"icmpConfiguration,omitempty" tf:"icmp_configuration,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	PreferredIPVersion *string `json:"preferredIpVersion,omitempty" tf:"preferred_ip_version,omitempty"`

	// +kubebuilder:validation:Required
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`

	// +kubebuilder:validation:Optional
	SuccessThreshold []SuccessThresholdParameters `json:"successThreshold,omitempty" tf:"success_threshold,omitempty"`

	// +kubebuilder:validation:Optional
	TCPConfiguration []TCPConfigurationParameters `json:"tcpConfiguration,omitempty" tf:"tcp_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	TestFrequencyInSeconds *float64 `json:"testFrequencyInSeconds,omitempty" tf:"test_frequency_in_seconds,omitempty"`
}

type TestGroupObservation struct {
}

type TestGroupParameters struct {

	// +kubebuilder:validation:Required
	DestinationEndpoints []*string `json:"destinationEndpoints" tf:"destination_endpoints,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	SourceEndpoints []*string `json:"sourceEndpoints" tf:"source_endpoints,omitempty"`

	// +kubebuilder:validation:Required
	TestConfigurationNames []*string `json:"testConfigurationNames" tf:"test_configuration_names,omitempty"`
}

// ConnectionMonitorSpec defines the desired state of ConnectionMonitor
type ConnectionMonitorSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ConnectionMonitorParameters `json:"forProvider"`
}

// ConnectionMonitorStatus defines the observed state of ConnectionMonitor.
type ConnectionMonitorStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ConnectionMonitorObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// ConnectionMonitor is the Schema for the ConnectionMonitors API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type ConnectionMonitor struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ConnectionMonitorSpec   `json:"spec"`
	Status            ConnectionMonitorStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ConnectionMonitorList contains a list of ConnectionMonitors
type ConnectionMonitorList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ConnectionMonitor `json:"items"`
}

// Repository type metadata.
var (
	ConnectionMonitor_Kind             = "ConnectionMonitor"
	ConnectionMonitor_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ConnectionMonitor_Kind}.String()
	ConnectionMonitor_KindAPIVersion   = ConnectionMonitor_Kind + "." + CRDGroupVersion.String()
	ConnectionMonitor_GroupVersionKind = CRDGroupVersion.WithKind(ConnectionMonitor_Kind)
)

func init() {
	SchemeBuilder.Register(&ConnectionMonitor{}, &ConnectionMonitorList{})
}
